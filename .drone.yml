kind: pipeline
type: docker
name: deploy-bot

steps:
  - name: build-and-deploy
    image: docker/compose:1.29.2
    volumes:
      - name: docker-sock
        path: /var/run/docker.sock
    environment:
      COMPOSE_PROJECT_NAME: asimogoBot
      TZ: Asia/Phnom_Penh
      # ↓ 从 Drone secrets 注入 ↓
      BOT_TOKEN:
        from_secret: BOT_TOKEN
      BAIDU_APPID:
        from_secret: BAIDU_APPID
      BAIDU_SECRET:
        from_secret: BAIDU_SECRET
      BAIDU_OCR_TOKEN:
        from_secret: BAIDU_OCR_TOKEN
      DEEPSEEK_API_KEY:
        from_secret: DEEPSEEK_API_KEY
      FLOMO_WEBHOOK:
        from_secret: FLOMO_WEBHOOK
      NOTION_API_KEY:
        from_secret: NOTION_API_KEY
      NOTION_PAGE_ID:
        from_secret: NOTION_PAGE_ID
      REDIS_URL: redis://192.168.0.105:6379
      NODE_ENV: production
    commands:
      - docker-compose version

      # 1) 必填项校验（逐个取"值"，不是"名字"）
      - |
        set -eu
        required_vars="BOT_TOKEN DEEPSEEK_API_KEY REDIS_URL NODE_ENV TZ \
                       BAIDU_APPID BAIDU_SECRET BAIDU_OCR_TOKEN \
                       FLOMO_WEBHOOK NOTION_API_KEY NOTION_PAGE_ID"
        missing=0
        echo "🔍 Checking required envs from Drone secrets..."
        for k in $required_vars; do
          v=$(eval "printf '%s' \"\${$k:-}\"")   # ← 关键修正：取到实际值
          if [ -z "$v" ]; then
            echo "❌ $k is EMPTY or missing"
            missing=1
          else
            echo "✅ $k is set"
          fi
        done
        [ "$missing" -eq 0 ] || { echo "⛔ Stop: some secrets are missing."; exit 1; }
        echo "✅ All required envs are present."

      # 2) 写入 .env（允许变量展开）
      - |
        cat > .env <<EOF
        BOT_TOKEN=${BOT_TOKEN}
        BAIDU_APPID=${BAIDU_APPID}
        BAIDU_SECRET=${BAIDU_SECRET}
        BAIDU_OCR_TOKEN=${BAIDU_OCR_TOKEN}
        DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
        FLOMO_WEBHOOK=${FLOMO_WEBHOOK}
        NOTION_API_KEY=${NOTION_API_KEY}
        NOTION_PAGE_ID=${NOTION_PAGE_ID}
        REDIS_URL=${REDIS_URL}
        NODE_ENV=${NODE_ENV}
        TZ=${TZ}
        EOF
        echo "✅ .env generated."

      # 3) 脱敏检查：确认 .env 不为空（不泄露值）
      - |
        echo "🔎 .env sanity check (masked):"
        awk -F= '{printf("%-18s %s\n",$1, ($2==""?"<EMPTY>":"<SET>"))}' .env

      # 4) 构建 + 启动（如有变化会重建），并清理孤儿容器
      - docker-compose -f docker-compose.prod.yml up -d --build --remove-orphans

      # 5) 基本状态与关键信息
      - docker-compose -f docker-compose.prod.yml ps
      - docker-compose -f docker-compose.prod.yml logs --tail=200 --no-color bot || true

      # 6) 容器内二次校验（确认 BOT_TOKEN 已注入；容器 running 才能 exec）
      - |
        # 等待最多 30s 直到容器变为 running（避免 "is restarting"）
        for i in $(seq 1 30); do
          state=$(docker inspect -f '{{.State.Running}}' "$(docker-compose -f docker-compose.prod.yml ps -q bot)")
          [ "$state" = "true" ] && break
          sleep 1
        done
        tok=$(docker-compose -f docker-compose.prod.yml exec -T bot /bin/sh -lc 'printenv BOT_TOKEN || true' || true)
        if [ -z "$tok" ]; then
          echo "❌ BOT_TOKEN is missing inside container."
          exit 1
        fi
        echo "✅ BOT_TOKEN is present inside container (value hidden)."

      # 7) 清理工作目录中的 .env（容器已拿到环境变量）
      - rm -f .env

volumes:
  - name: docker-sock
    host:
      path: /var/run/docker.sock

trigger:
  branch:
    - main
  event:
    - push
